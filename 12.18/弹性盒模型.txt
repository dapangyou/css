弹性盒模型fiexbox
  块级元素一般会默认是独占一行因此会竖着排列的，之前的做法就是将需要水平排列的盒子设置float: left来将盒子水平排列
  现在可以使用弹性盒子来设置盒子水平排列
  设置弹性盒子模型
	1.设置父元素为弹性盒子 display: flex
	2.(1)设置子元素所占的宽度的比例
			flex-grow: number  (例如：flex-grow: 1 表示的意思是宽度各占1:1:1)
	  (2) 设置子元素垂直排列
		  在父元素中加上属性： flex-direction: column
	  (3) 弹性盒居中
		  以前的方式：
			如果想要一个子盒子在父盒子中居中
			首先水平居中margin: a auto
		    然后需要垂直居中，就需要使用到margin-top属性来设置了，这样的作法会将多余的部分溢出，就需要使用到overflow: hidden来进行隐藏
		  现在弹性盒的做法是：（写在父元素上，但是对子元素生效）
			首先在父元素中水平居中的属性是justify-content: center
			然后进行垂直居中的属性是: align-items: center
			这两个属性的相配合就可以使得子盒子相对于父盒子居中了。
	


	在学习清除浮动的时候遇到有不太明白的问题，overflow: hidden清除浮动的机制原理等，下面将会对overflow: hidden来进行深入的解释
	1.如果有内容溢出盒子的宽度或是高度的情况，内容会溢出，所以需要将溢出的部分的内容进行隐藏，因此需要使用到overflow: hidden
	2.使用overflow: hidden来清除浮动
		首先为什么要清除浮动？？？？
		一般父元素的高度是auto，也就是说父元素的高度是由子元素的高度来确定的，如果这个时候子元素全部都浮动，也就是说子元素就脱离了标准的文档流了，不占有高度
		所以这个时候父元素就没有了高度了，换句话说就是父元素就没有了。父元素一点作用都不起，如果其他标准流盒子随时会覆盖掉浮动的盒子
		遇到这种问题的解决办法：
			2.1  首先想到的解决办法就是将父元素也浮动
			但是父元素浮动之后，就不是标准的盒子模型了，就不会独占一行了，需要自己设置宽度
			2.2  其次想到的解决办法就是清除浮动带来的影响：
				 overflow: hidden
				 这种方式还是可以独占一行，比父元素浮动的方式要好一些
	3.如果有两个盒子，两个盒子垂直方向排列，如果上面的盒子设置margin-bottom下面的盒子设置margin-top，这个时候两个盒子选择其中一个比较大的边距生效
	 也就是说两个盒子中间的差距是较大的那个边距值
	  如果想要两个边距都生效，解决办法
		3.1 设置父元素盒子的边框透明 例如：border-top：1px solid transparent
		3.2 为父元素添加padding
		3.3使用overflow: hidden
		
	自适应的问题，终于知道了
	当缩小屏幕宽度的时候，图片不会跟着缩小，这样的体验非常的不好
	因此需要设置图片的宽度的百分比，意思是，该图片占父级元素的百分比
	而且当浏览器的屏幕一直缩小的时候，如果这个时候图片再继续的缩小会显得不好看，因此需要设置一个
	最小宽度
		
		